"""
Hand-written WebSocket client for real-time orderbook and trade streaming.

Provides a stateful local orderbook that applies snapshots + deltas
so consumers always get a materialized book. Handles auth, reconnect
with exponential backoff, resubscribe, sequence gap detection, and resync.

NOT generated by Stainless — this file lives on the ``next`` branch and
persists across SDK regenerations.
"""

from __future__ import annotations

import asyncio
import json
import math
from dataclasses import dataclass, field
from typing import Any, Callable, Awaitable, Dict, List, Optional, Sequence, Union

import websockets
import websockets.asyncio.client

# ── Public types ─────────────────────────────────────────────


@dataclass
class StreamingOrderbookLevel:
    price: float
    size: float


@dataclass
class OrderbookSnapshot:
    parsec_id: str
    outcome: str
    exchange: str
    token_id: str
    market_id: str
    bids: List[StreamingOrderbookLevel]
    asks: List[StreamingOrderbookLevel]
    mid_price: float
    spread: float
    tick_size: Optional[float]
    kind: str  # "snapshot" | "delta"
    server_seq: int
    feed_state: str  # "healthy" | "degraded" | "disconnected"
    book_state: str  # "fresh" | "stale"
    stale_after_ms: int
    exchange_ts_ms: Optional[int]
    ingest_ts_ms: Optional[int]


@dataclass
class Activity:
    parsec_id: str
    outcome: str
    exchange: str
    token_id: str
    market_id: str
    kind: str  # "trade" | "fill"
    price: float
    size: float
    side: Optional[str]
    aggressor_side: Optional[str]
    trade_id: Optional[str]
    fill_id: Optional[str]
    order_id: Optional[str]
    server_seq: int
    feed_state: str
    exchange_ts_ms: Optional[int]
    ingest_ts_ms: Optional[int]
    source_channel: str


@dataclass
class WsError:
    message: str
    code: Optional[int] = None
    parsec_id: Optional[str] = None


@dataclass
class MarketSubscription:
    parsec_id: str
    outcome: Optional[str] = None
    depth: Optional[int] = None


# ── Internal types ───────────────────────────────────────────

_PRICE_EPSILON = 1e-9
_MAX_RECONNECT_DELAY_MS = 30_000
_BASE_RECONNECT_DELAY_MS = 1_000

# Callback types
_OrderbookCb = Callable[[OrderbookSnapshot], Awaitable[None]]
_ActivityCb = Callable[[Activity], Awaitable[None]]
_ErrorCb = Callable[[WsError], Awaitable[None]]
_ConnectedCb = Callable[[], Awaitable[None]]
_DisconnectedCb = Callable[[str], Awaitable[None]]
_ReconnectingCb = Callable[[int, int], Awaitable[None]]
_SlowReaderCb = Callable[[str, str], Awaitable[None]]
_HeartbeatCb = Callable[[int], Awaitable[None]]


@dataclass
class _LocalBook:
    parsec_id: str
    outcome: str
    exchange: str
    token_id: str
    market_id: str
    bids: List[StreamingOrderbookLevel] = field(default_factory=list)
    asks: List[StreamingOrderbookLevel] = field(default_factory=list)
    tick_size: Optional[float] = None
    last_seq: int = 0


# ── Helpers ──────────────────────────────────────────────────


def _compute_mid_spread(
    bids: List[StreamingOrderbookLevel],
    asks: List[StreamingOrderbookLevel],
) -> tuple[float, float]:
    best_bid = bids[0].price if bids else 0.0
    best_ask = asks[0].price if asks else 0.0
    if best_bid > 0 and best_ask > 0:
        mid = (best_bid + best_ask) / 2
        spread = abs(best_ask - best_bid)
    else:
        mid = best_bid or best_ask
        spread = 0.0
    return mid, spread


def _parse_wire_levels(raw: Any) -> List[StreamingOrderbookLevel]:
    if not isinstance(raw, list):
        return []
    levels: List[StreamingOrderbookLevel] = []
    for item in raw:
        if isinstance(item, (list, tuple)) and len(item) >= 2:
            try:
                levels.append(StreamingOrderbookLevel(price=float(item[0]), size=float(item[1])))
            except (TypeError, ValueError):
                continue
    return levels


def _market_key(parsec_id: str, outcome: str) -> str:
    return f"{parsec_id}:{outcome}"


def _sub_key(parsec_id: str, outcome: Optional[str] = None) -> str:
    return f"{parsec_id}:{outcome}" if outcome else parsec_id


# ── WebSocket client ─────────────────────────────────────────


class ParsecWebSocket:
    """Async WebSocket client with stateful local orderbook."""

    def __init__(self, api_key: str, ws_url: str) -> None:
        self._api_key = api_key
        self._ws_url = ws_url

        self._ws: Optional[websockets.asyncio.client.ClientConnection] = None
        self._state = "disconnected"
        self._intentional_close = False
        self._reconnect_attempt = 0
        self._reconnect_task: Optional[asyncio.Task[None]] = None
        self._recv_task: Optional[asyncio.Task[None]] = None

        self._subscriptions: Dict[str, MarketSubscription] = {}
        self._books: Dict[str, _LocalBook] = {}

        # Listeners
        self._on_orderbook: List[_OrderbookCb] = []
        self._on_activity: List[_ActivityCb] = []
        self._on_error: List[_ErrorCb] = []
        self._on_connected: List[_ConnectedCb] = []
        self._on_disconnected: List[_DisconnectedCb] = []
        self._on_reconnecting: List[_ReconnectingCb] = []
        self._on_slow_reader: List[_SlowReaderCb] = []
        self._on_heartbeat: List[_HeartbeatCb] = []

    # ── Event registration (decorator style) ───────────────

    def on(self, event: str) -> Callable[..., Any]:
        """Register an event handler. Use as a decorator:

        @ws.on("orderbook")
        async def handle(book: OrderbookSnapshot):
            ...
        """

        def decorator(fn: Any) -> Any:
            if event == "orderbook":
                self._on_orderbook.append(fn)
            elif event == "activity":
                self._on_activity.append(fn)
            elif event == "error":
                self._on_error.append(fn)
            elif event == "connected":
                self._on_connected.append(fn)
            elif event == "disconnected":
                self._on_disconnected.append(fn)
            elif event == "reconnecting":
                self._on_reconnecting.append(fn)
            elif event == "slow_reader":
                self._on_slow_reader.append(fn)
            elif event == "heartbeat":
                self._on_heartbeat.append(fn)
            return fn

        return decorator

    # ── Emit helpers ───────────────────────────────────────

    async def _emit_orderbook(self, book: OrderbookSnapshot) -> None:
        for cb in self._on_orderbook:
            try:
                await cb(book)
            except Exception:
                pass

    async def _emit_activity(self, activity: Activity) -> None:
        for cb in self._on_activity:
            try:
                await cb(activity)
            except Exception:
                pass

    async def _emit_error(self, err: WsError) -> None:
        for cb in self._on_error:
            try:
                await cb(err)
            except Exception:
                pass

    async def _emit_connected(self) -> None:
        for cb in self._on_connected:
            try:
                await cb()
            except Exception:
                pass

    async def _emit_disconnected(self, reason: str) -> None:
        for cb in self._on_disconnected:
            try:
                await cb(reason)
            except Exception:
                pass

    async def _emit_reconnecting(self, attempt: int, delay_ms: int) -> None:
        for cb in self._on_reconnecting:
            try:
                await cb(attempt, delay_ms)
            except Exception:
                pass

    async def _emit_slow_reader(self, parsec_id: str, outcome: str) -> None:
        for cb in self._on_slow_reader:
            try:
                await cb(parsec_id, outcome)
            except Exception:
                pass

    async def _emit_heartbeat(self, ts_ms: int) -> None:
        for cb in self._on_heartbeat:
            try:
                await cb(ts_ms)
            except Exception:
                pass

    # ── Connection lifecycle ───────────────────────────────

    async def connect(self) -> None:
        """Connect and authenticate. Resolves after auth_ok, raises on auth_error."""
        if self._state in ("connected", "connecting", "authenticating"):
            return

        self._intentional_close = False
        self._reconnect_attempt = 0
        await self._do_connect(initial=True)

    async def close(self) -> None:
        """Close the connection, cancel reconnect, clear all state."""
        self._intentional_close = True
        self._state = "closed"

        if self._reconnect_task and not self._reconnect_task.done():
            self._reconnect_task.cancel()
            try:
                await self._reconnect_task
            except (asyncio.CancelledError, Exception):
                pass
            self._reconnect_task = None

        if self._recv_task and not self._recv_task.done():
            self._recv_task.cancel()
            try:
                await self._recv_task
            except (asyncio.CancelledError, Exception):
                pass
            self._recv_task = None

        self._subscriptions.clear()
        self._books.clear()

        if self._ws:
            try:
                await self._ws.close()
            except Exception:
                pass
            self._ws = None

        await self._emit_disconnected("Client closed")

    async def __aenter__(self) -> "ParsecWebSocket":
        await self.connect()
        return self

    async def __aexit__(self, *args: Any) -> None:
        await self.close()

    # ── Subscribe / unsubscribe ────────────────────────────

    def subscribe(
        self,
        markets: Union[MarketSubscription, Sequence[MarketSubscription], None] = None,
        *,
        parsec_id: Optional[str] = None,
        outcome: Optional[str] = None,
        depth: Optional[int] = None,
    ) -> None:
        """Subscribe to markets. Accepts a single MarketSubscription, a list, or keyword args."""
        if markets is None and parsec_id is not None:
            markets = [MarketSubscription(parsec_id=parsec_id, outcome=outcome, depth=depth)]
        elif isinstance(markets, MarketSubscription):
            markets = [markets]
        elif markets is None:
            return

        to_send: List[MarketSubscription] = []
        for m in markets:
            key = _sub_key(m.parsec_id, m.outcome)
            if key not in self._subscriptions:
                self._subscriptions[key] = m
                to_send.append(m)

        if to_send and self._state == "connected":
            self._ws_send(
                {
                    "type": "subscribe",
                    "markets": [
                        {"parsec_id": m.parsec_id, "outcome": m.outcome, "depth": m.depth}
                        for m in to_send
                    ],
                }
            )

    def unsubscribe(
        self,
        markets: Union[MarketSubscription, Sequence[MarketSubscription], None] = None,
        *,
        parsec_id: Optional[str] = None,
        outcome: Optional[str] = None,
    ) -> None:
        """Unsubscribe from markets."""
        if markets is None and parsec_id is not None:
            markets = [MarketSubscription(parsec_id=parsec_id, outcome=outcome)]
        elif isinstance(markets, MarketSubscription):
            markets = [markets]
        elif markets is None:
            return

        to_send: List[MarketSubscription] = []
        for m in markets:
            key = _sub_key(m.parsec_id, m.outcome)
            if key in self._subscriptions:
                del self._subscriptions[key]
                to_send.append(m)

                if m.outcome:
                    self._books.pop(_market_key(m.parsec_id, m.outcome), None)
                else:
                    keys_to_remove = [k for k in self._books if k.startswith(f"{m.parsec_id}:")]
                    for k in keys_to_remove:
                        del self._books[k]

        if to_send and self._state == "connected":
            self._ws_send(
                {
                    "type": "unsubscribe",
                    "markets": [{"parsec_id": m.parsec_id, "outcome": m.outcome} for m in to_send],
                }
            )

    async def run_forever(self) -> None:
        """Block until the connection is closed."""
        while self._state not in ("closed",) and not self._intentional_close:
            await asyncio.sleep(0.1)

    # ── Internals ──────────────────────────────────────────

    async def _do_connect(self, initial: bool = False) -> None:
        if self._ws:
            try:
                await self._ws.close()
            except Exception:
                pass
            self._ws = None

        self._state = "connecting"

        try:
            self._ws = await websockets.asyncio.client.connect(self._ws_url, open_timeout=10)
        except Exception as exc:
            await self._emit_error(WsError(message=str(exc)))
            if initial:
                raise
            self._schedule_reconnect()
            return

        self._state = "authenticating"
        await self._emit_connected()

        # Send auth
        self._ws_send({"type": "auth", "api_key": self._api_key})

        if initial:
            # Wait for auth response synchronously for the initial connect()
            try:
                raw = await self._ws.recv()
                msg = json.loads(raw)
            except Exception as exc:
                await self._emit_disconnected("Connection closed during authentication")
                raise ConnectionError("Connection closed during authentication") from exc

            if msg.get("type") == "auth_ok":
                self._state = "connected"
                self._reconnect_attempt = 0
                self._resubscribe_all()
                # Start background receive loop
                self._recv_task = asyncio.create_task(self._recv_loop())
            elif msg.get("type") == "auth_error":
                err_msg = msg.get("message", "Authentication failed")
                await self._emit_error(WsError(code=msg.get("code"), message=err_msg))
                self._intentional_close = True
                self._state = "closed"
                try:
                    await self._ws.close()
                except Exception:
                    pass
                self._ws = None
                raise ConnectionError(err_msg)
            else:
                raise ConnectionError(f"Unexpected auth response: {msg.get('type')}")
        else:
            # Reconnect path: start recv loop which handles auth
            self._recv_task = asyncio.create_task(self._recv_loop())

    async def _recv_loop(self) -> None:
        try:
            assert self._ws is not None
            async for raw in self._ws:
                if self._intentional_close:
                    return
                try:
                    msg = json.loads(raw)
                    await self._handle_server_message(msg)
                except json.JSONDecodeError:
                    continue
        except (
            websockets.exceptions.ConnectionClosed,
            websockets.exceptions.ConnectionClosedError,
            websockets.exceptions.ConnectionClosedOK,
        ):
            pass
        except asyncio.CancelledError:
            return
        except Exception:
            pass
        finally:
            self._ws = None
            if not self._intentional_close:
                self._state = "disconnected"
                await self._emit_disconnected("Connection closed")
                self._schedule_reconnect()

    async def _handle_server_message(self, msg: Any) -> None:
        msg_type = msg.get("type")

        if msg_type == "auth_ok":
            self._state = "connected"
            self._reconnect_attempt = 0
            self._resubscribe_all()

        elif msg_type == "auth_error":
            err_msg = msg.get("message", "Authentication failed")
            await self._emit_error(WsError(code=msg.get("code"), message=err_msg))
            self._intentional_close = True
            self._state = "closed"
            if self._ws:
                try:
                    await self._ws.close()
                except Exception:
                    pass
                self._ws = None

        elif msg_type == "orderbook":
            await self._handle_orderbook_snapshot(msg)

        elif msg_type == "orderbook_delta":
            await self._handle_orderbook_delta(msg)

        elif msg_type == "activity":
            await self._emit_activity(
                Activity(
                    parsec_id=msg.get("parsec_id", ""),
                    outcome=msg.get("outcome", ""),
                    exchange=msg.get("exchange", ""),
                    token_id=msg.get("token_id", ""),
                    market_id=msg.get("market_id", ""),
                    kind=msg.get("kind", "trade"),
                    price=msg.get("price", 0),
                    size=msg.get("size", 0),
                    side=msg.get("side"),
                    aggressor_side=msg.get("aggressor_side"),
                    trade_id=msg.get("trade_id"),
                    fill_id=msg.get("fill_id"),
                    order_id=msg.get("order_id"),
                    server_seq=msg.get("server_seq", 0),
                    feed_state=msg.get("feed_state", "healthy"),
                    exchange_ts_ms=msg.get("exchange_ts_ms"),
                    ingest_ts_ms=msg.get("ingest_ts_ms"),
                    source_channel=msg.get("source_channel", ""),
                )
            )

        elif msg_type == "heartbeat":
            await self._emit_heartbeat(msg.get("ts_ms", 0))

        elif msg_type == "resync_required":
            parsec_id = msg.get("parsec_id", "")
            outcome = msg.get("outcome")
            self._ws_send({"type": "resync", "parsec_id": parsec_id, "outcome": outcome})

        elif msg_type == "slow_reader":
            await self._emit_slow_reader(msg.get("parsec_id", ""), msg.get("outcome", ""))

        elif msg_type == "error":
            await self._emit_error(
                WsError(
                    code=msg.get("code"),
                    message=msg.get("message", "Server error"),
                    parsec_id=msg.get("parsec_id"),
                )
            )

    async def _handle_orderbook_snapshot(self, msg: Any) -> None:
        parsec_id: str = msg.get("parsec_id", "")
        outcome: str = msg.get("outcome", "")
        exchange: str = msg.get("exchange", "")
        token_id: str = msg.get("token_id", "")
        market_id: str = msg.get("market_id", "")

        bids = _parse_wire_levels(msg.get("bids"))
        asks = _parse_wire_levels(msg.get("asks"))

        # Sort: bids descending, asks ascending.
        bids.sort(key=lambda l: l.price, reverse=True)
        asks.sort(key=lambda l: l.price)

        key = _market_key(parsec_id, outcome)
        seq: int = msg.get("server_seq", 0)

        self._books[key] = _LocalBook(
            parsec_id=parsec_id,
            outcome=outcome,
            exchange=exchange,
            token_id=token_id,
            market_id=market_id,
            bids=bids,
            asks=asks,
            tick_size=msg.get("tick_size"),
            last_seq=seq,
        )

        mid, spread = _compute_mid_spread(bids, asks)

        await self._emit_orderbook(
            OrderbookSnapshot(
                parsec_id=parsec_id,
                outcome=outcome,
                exchange=exchange,
                token_id=token_id,
                market_id=market_id,
                bids=bids,
                asks=asks,
                mid_price=mid,
                spread=spread,
                tick_size=msg.get("tick_size"),
                kind="snapshot",
                server_seq=seq,
                feed_state=msg.get("feed_state", "healthy"),
                book_state=msg.get("book_state", "fresh"),
                stale_after_ms=msg.get("stale_after_ms", 0),
                exchange_ts_ms=msg.get("exchange_ts_ms"),
                ingest_ts_ms=msg.get("ingest_ts_ms"),
            )
        )

    async def _handle_orderbook_delta(self, msg: Any) -> None:
        parsec_id: str = msg.get("parsec_id", "")
        outcome: str = msg.get("outcome", "")
        key = _market_key(parsec_id, outcome)
        book = self._books.get(key)

        # Delta before first snapshot — ignore.
        if book is None:
            return

        seq: int = msg.get("server_seq", 0)

        # Sequence gap detection.
        if book.last_seq > 0 and seq != book.last_seq + 1:
            self._ws_send({"type": "resync", "parsec_id": parsec_id, "outcome": outcome})
            return

        book.last_seq = seq

        # Apply absolute replacement semantics.
        changes = msg.get("changes", [])
        for ch in changes:
            price = ch.get("price")
            size = ch.get("size")
            side = ch.get("side")
            if not isinstance(price, (int, float)) or not isinstance(size, (int, float)):
                continue

            levels = book.bids if side == "bid" else book.asks

            if size <= 0:
                # Remove level
                book_levels = [l for l in levels if abs(l.price - price) >= _PRICE_EPSILON]
                if side == "bid":
                    book.bids = book_levels
                else:
                    book.asks = book_levels
                levels = book_levels
                continue

            # Set / update level
            found = False
            for i, l in enumerate(levels):
                if abs(l.price - price) < _PRICE_EPSILON:
                    levels[i] = StreamingOrderbookLevel(price=price, size=size)
                    found = True
                    break

            if not found:
                levels.append(StreamingOrderbookLevel(price=price, size=size))

        # Re-sort.
        book.bids.sort(key=lambda l: l.price, reverse=True)
        book.asks.sort(key=lambda l: l.price)

        mid, spread = _compute_mid_spread(book.bids, book.asks)

        await self._emit_orderbook(
            OrderbookSnapshot(
                parsec_id=book.parsec_id,
                outcome=book.outcome,
                exchange=book.exchange,
                token_id=book.token_id,
                market_id=book.market_id,
                bids=book.bids,
                asks=book.asks,
                mid_price=mid,
                spread=spread,
                tick_size=book.tick_size,
                kind="delta",
                server_seq=seq,
                feed_state=msg.get("feed_state", "healthy"),
                book_state=msg.get("book_state", "fresh"),
                stale_after_ms=msg.get("stale_after_ms", 0),
                exchange_ts_ms=msg.get("exchange_ts_ms"),
                ingest_ts_ms=msg.get("ingest_ts_ms"),
            )
        )

    # ── Reconnect ──────────────────────────────────────────

    def _schedule_reconnect(self) -> None:
        if self._intentional_close:
            return

        self._state = "reconnecting"
        self._reconnect_attempt += 1
        delay_ms = min(
            _BASE_RECONNECT_DELAY_MS * (2 ** (self._reconnect_attempt - 1)),
            _MAX_RECONNECT_DELAY_MS,
        )

        async def _reconnect() -> None:
            await self._emit_reconnecting(self._reconnect_attempt, delay_ms)
            await asyncio.sleep(delay_ms / 1000.0)
            if self._intentional_close:
                return
            await self._do_connect(initial=False)

        self._reconnect_task = asyncio.create_task(_reconnect())

    def _resubscribe_all(self) -> None:
        if not self._subscriptions:
            return
        markets = [
            {"parsec_id": m.parsec_id, "outcome": m.outcome, "depth": m.depth}
            for m in self._subscriptions.values()
        ]
        self._ws_send({"type": "subscribe", "markets": markets})

    def _ws_send(self, msg: Any) -> None:
        if self._ws:
            try:
                # Use the sync-compatible send (queues internally in websockets)
                asyncio.ensure_future(self._ws.send(json.dumps(msg)))
            except Exception:
                pass
